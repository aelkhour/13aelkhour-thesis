\chapter{Dynamic Walking and Whole-Body Motion Planning for Humanoid Robots: an Integrated Approach}
\label{chap:wholebody-planning}

The humanoid walk motion planning problem was tackled in Chapter
\ref{chap:path-optim} by first planning a geometric path for the robot
bounding box, then transforming the path into a dynamic walking
trajectory by laying footprints along it and using a pattern
generator.  However, in complex and difficult environments, such as
the one presented in Section \ref{subsec:chap1-chairs}, it can be
necessary to consider exact 3D models of a humanoid robot and its
environment.

This chapter presents a general method for planning collision-free
whole-body walking motions for humanoid robots. We rely on a
randomized algorithm for constrained motion planning; it is used to
generate collision-free statically balanced paths solving manipulation
tasks. Then, we show that dynamic walking makes a humanoid robot
small-space controllable. Such a property allows to easily transform
collision-free statically balanced paths into collision-free
dynamically balanced trajectories. It leads to a sound algorithm which
has been applied and evaluated on several problems where whole-body
planning and walk are needed, and the results have been validated on
the HRP-2 robot.

\section{Motion Planning in Submanifolds of the Configuration Space}
\label{sec:chap2-planning-submanifolds}

Sampling-based planners, such as the ones presented in Section
\ref{subsec:chap1-sampling-algorithms}, have encountered wide success
in generating collision-free paths in high-dimension configuration
spaces. When using sampling techniques on a humanoid robot, a major
difficulty is to take into account balance constraints, i.e. to
generate random configurations on zero volume submanifolds of
{\cspace}. Indeed, the probability of sampling a configuration
\config{rand} in {\cspace} such that it lies on such manifolds is
zero. In this section, we present recent advances in motion planning
on constraint manifolds using inverse-kinematics (IK) solvers.

\subsection{Inverse Kinematics}
\label{subsec:chap2-inverse-kinematics}

The problem of inverse kinematics for a humanoid robot, or any
articulated structure, is to compute a configuration \config{} to
achieve a task \task{}. This task is usually expressed in the
Cartesian space, and can represent and end-effector position and/or
orientation, the CoM position, etc. Some tasks may have more than one
solution configuration, see Section
\ref{subsec:chap1-kinematic-redundancy}. In the case of most robotics
tasks, the set of solution configurations has a specific topological
structure and forms a differentiable submanifold $\manifold$ of
{\cspace}, i.e. a set that locally ``looks like'' the euclidean
space \tspace{m}, and such that the tangent vector space
$T_{\mathbf{q}}\manifold$ is defined for any \config{}. $m$ is called
the dimension of the manifold $\manifold$.

As the robots we deal with are redundant, it is natural to take
advantage of this redundancy by specifying multiple tasks, potentially
with different priorities. This problem has been widely studied in
robotics planning and control literature, and many Jacobian-based
solutions have been proposed, among which \cite{nakamura1986iks},
\cite{siciliano1991gfm}, \cite{baerlocher1998tpf},
\cite{khatib2004wbd} and \cite{kano09}. Obstacle avoidance can be
taken into account with similar methods. To do so, one has to include
the obstacles as constraints to satisfy, see for example
\cite{kanehiro2008lca}. These methods are prone to fall into local
minima, thus global motion planning is needed to overcome this
limitation. Note that when local methods find solutions, these are
usually smoother and may look more natural. The choice of using global
motion planners is justified by the need for complete algorithms.

We show here a functional example of an IK solver: its purpose is to
find the root \config{} of a non-linear $C^1$ function $f(q)$ with a
tolerance of $\epsilon$. If we want to find a configuration on a
manifold $\manifold$, $\mathbf{f}(\mathbf{q})$ can be defined as a
vector-valued function that contains the concatenation of all
constraints defining $\manifold$. Note that as the intersection of two
or more manifolds is also a manifold, this constraint solver allows us
also to generate configurations that lie at the intersection of
several manifolds.

Algorithm~\ref{algo:newton} implements a Newton-Raphson method
\cite{bonnans2006numerical}: starting from an initial value of
\config{}, \config{} is updated iteratively by $- \alpha
\left(\frac{\partial \mathbf{f}}{\partial
  \mathbf{q}}(\mathbf{q})\right)^{+} \mathbf{f}(\mathbf{q})$, where
$\alpha$ denotes a gain and $\left(\frac{\partial \mathbf{f}}{\partial
  \mathbf{q}}(\mathbf{q})\right)^{+}$ denotes the Moore-Penrose
pseudo-inverse of the Jacobian of $\mathbf{f}(\mathbf{q})$. The use of
an adaptive gain $\alpha$, which increases iteratively from an initial
value $\alpha$ to a maximum value $\alpha_{max}\in[0,1]$, allows the
overshoot avoidance and convergence acceleration. The update rule
relies on a real factor $w \in [0,1]$; the greater $w$ is, the faster
$\alpha$ will reach $\alpha_{max}$. Obviously, the solver convergence
depends on the initial value of \config{}, and a bad initialization
can lead to either slow convergence or failure. A cutoff number of
iterations $it_{max}$ is hence introduced to bypass these cases.

In practice, we observe that values of $\epsilon=10^{-6}$,
$\alpha=0.1$, $\alpha_{max}=0.95$ and $w=0.8$ lead to good behavior,
i.e. fast convergence and low failure rate. These values are kept
constant for all scenarios in this work.

\begin{algorithm}
\caption{\texttt{SolveConstraints}(\config{}, $\mathbf{f}$, $\epsilon$): find
  \config{} such that $\mathbf{f}(\mathbf{q}) = 0$}
\label{algo:newton}
\begin{algorithmic}
\STATE $i=0$
\WHILE{$\|\mathbf{f}(\mathbf{q})\| > \epsilon$ and $i\leq it_{max}$}
\STATE {\color{red} // $\left(.\right)^{+}$ denotes the Moore-Penrose pseudo-inverse}
\STATE $\mathbf{q} \leftarrow$ $\mathbf{q} - \alpha \left(\frac{\partial \mathbf{f}}{\partial \mathbf{q}}(\mathbf{q})\right)^{+} \mathbf{f}(\mathbf{q})$
\STATE $i$ $\leftarrow$ $i+1$
\STATE {\color{red}// Make $\alpha$ tend toward $\alpha_{max}$}
\STATE $\alpha \rightarrow \alpha_{max} - w(\alpha_{max} - \alpha)$
\ENDWHILE
\IF {$\|\mathbf{f}(\mathbf{q})\| \leq \epsilon$}
\STATE return \config{}
\ELSE
\STATE return failure
\ENDIF
\end{algorithmic}
\end{algorithm}

\subsection{Randomized Motion Planning on Constraint Manifolds}
\label{subsec:chap2-constraint-motion-planning}

This problem of motion planning on constraint submanifolds of
{\cspace} has been investigated with success during the last few
years; the work of \cite{berenson2011task} presents an exhaustive
survey of Jacobian-based methods. Other recent contributions
\cite{porta2012randomized} present sophisticated constrained motion
planning techniques based on higher-dimensional continuation.

This section presents an algorithm for constrained motion planning on
a submanifold $\manifold$ of the configuration space {\cspace}. It
presents a simple adaptation of the RRT algorithm to constrained
motion planning, that was first introduced in \cite{dalibard09}. A
configuration \config{} of {\cspace} is said to be valid iff, beside
being collision-free, it lies on the manifold $\manifold$ up to the
tolerance $\epsilon$; we call $\manifold$ the planning manifold.

The problem solved here differs from classic approaches in two ways:
\begin{enumerate}
\item the set of valid configurations is defined implicitly, as the
  set of collision-free configurations satisfying a given set of
  inverse kinematics balance constraints;
\item the goal manifold $\goalmanifold$ is also defined implicitly,
  by additional inverse kinematics constraints.
\end{enumerate}
During global planning, several types of constraints are considered
for various reasons:
\begin{itemize}
\item Static balance: the CoM of the robot stays above the support
  polygon center, the two feet are horizontal on the ground.
\item End-effector position and orientation: the goals of some
  problems presented in the experimental section of this chapter are
  defined as a specific robot hand pose, or a gaze direction.
\item Configuration task: this adaptation of randomized motion
  planning algorithms uses tasks defined as the distance towards a
  given configuration in {\cspace}. This will be detailed in the
  following section.
\end{itemize}

This formulation of manipulation planning does not include an explicit
goal configuration, so it is not possible to directly grow a tree from
the goal. To make use of the idea of growing multiple trees, the goal
manifold is first randomly sampled and several goal configurations are
generated. Then, random trees are grown from the initial configuration
and the random goal configurations. The idea of generating several
goals for manipulation planning was proposed in \cite{diankov2008bpc}.

\subsubsection{Goal Manifold Sampling}
\label{subsubsec:chap2-goal-sampling}

A goal configuration is generated using the following algorithm:
\begin{enumerate}
\item Shoot a random configuration \config{rand} in {\cspace} with
  uniform distribution.
\item Call \texttt{SolveConstraints} (Algorithm~\ref{algo:newton}) on
  \config{rand}, with $f(q)$ defined by the intersection of the planning
  and goal manifolds $\manifold \cap \goalmanifold$.
\item If success, check for collisions.
\end{enumerate}

Figure~\ref{fig:goal} shows resulting random configurations which
satisfy both balance ($\manifold$) and reaching ($\goalmanifold$)
constraints for the HRP-2 robot.

\begin{figure}
\centerline {
\includegraphics[width=.24\linewidth]
                {src/chap2-wholebody-planning/pics/goal-config/goal0.png}
\includegraphics[width=.24\linewidth]
                {src/chap2-wholebody-planning/pics/goal-config/goal1.png}
\includegraphics[width=.24\linewidth]
                {src/chap2-wholebody-planning/pics/goal-config/goal2.png}
\includegraphics[width=.24\linewidth]
                {src/chap2-wholebody-planning/pics/goal-config/goal3.png}
}

\caption{Random goal configurations solving a reaching task. All the
  configurations are balanced and collision-free, and the right hand
  of the robot reaches the orange ball.}
\label{fig:goal}
\end{figure}

\subsubsection{Random Extensions on a Constrained Manifold}
\label{sec:extension}

Figure~\ref{fig:rrt-extend} shows an extension of the classic RRT
algorithm, from a configuration already in the tree \config{near} towards
a random configuration \config{rand}.

\begin{figure}
  \centering

  \begin{tikzpicture}[x=0.45cm,y=0.45cm]

    \node [draw,circle,inner sep=2pt] (0) at (0,0) {};
    \node [draw,circle,inner sep=2pt] (1) at (1,1) {};
    \node [draw,circle,inner sep=2pt] (2) at (2.4,1) {};
    \node [draw,circle,inner sep=2pt,fill=gray] (qn) at (3.4,2) {};
    \node [above left] at (qn) {\config{near}};
    \node (t) at (1.5,-0.5) {$\mathcal{T}$};
    \draw (0) -- (1) -- (2) -- (qn) ; 

    \node [draw,circle,inner sep=2pt] (qn2) at (7.6,2) {};
    \node [above left] at (qn2) {\config{new}};

    \draw (qn) -- (qn2) ;

    \path[draw=black,line join=miter,line cap=butt,line width=0.800pt, fill=gray]
    (8,2) .. controls (8,4) and (10,6) ..
    (12,5) .. controls (14,4) and (14,4) ..
    (15,2) .. controls (15,0) and (14,0) ..
    (13,0) .. controls (11,1) and (8,1) ..
    (8,2) -- cycle;

    \node [draw,circle,inner sep=2pt,fill=white] (qrand) at (13,2) {};
    \node [below] at (qrand) {\config{rand}};
    \node at (10.5,4) {Obstacle};
    \draw [dashed,thin] (qn2) -- (qrand) ;
  \end{tikzpicture}

  \caption{One step of extension of the RRT algorithm. The algorithm
    tries to add the longest possible edge from \config{near} towards
    \config{rand}, while avoiding collisions.}
  \label{fig:rrt-extend}
\end{figure}

The equivalent random extension on a constrained manifold $\manifold$,
defined by the constraint function $f$, starts from a valid
configuration {\config{near}} $ \in \manifold$, and extends the tree
towards a random configuration \config{rand}, while keeping the
constraints satisfied. Note that {\config{rand}} $ \notin\manifold$.
Extension attempts orthogonal to $\manifold$ are useless, as newly
added edges have to be included in $\manifold$. To extend in
directions that follow the directions of $\manifold$, we rely on
Jacobian-based inverse kinematics. Algorithm~\ref{alg:constrained}
presents the adaptation of the classic extend function, and
Figure~\ref{fig:gikrrt} illustrates this extension. The idea is to
first project \config{rand} on the tangent space to $\manifold$ at
\config{near}. Let us call the projected configuration
\config{rand}$'$. Let \config{rand}$''$ be the result of a call to
$\texttt{SolveConstraints}($\config{rand}$',\mathbf{f},\epsilon)$.  It
is the projection of \config{rand}$'$ on $\manifold$. Instead of
extending the tree from \config{near} towards \config{rand}, the
algorithm tries to extend from \config{near} towards \config{rand}$''$
while remaining on $\manifold$. While extending the tree, the
configurations along the new edge are automatically projected onto
$\manifold$. These projections are not very costly if the edge is
close to the constrained manifold.

\cite{berenson2011task} presents a formal proof that projection-based
constrained random motion planning on a fixed dimension manifold is
probabilistically complete. This proof applies equally to this
algorithm.

\begin{figure}
\centering
\begin{minipage}[c]{0.6\linewidth}
\begin{tikzpicture}[y=0.55pt, x=0.55pt,yscale=-1, inner sep=0pt, outer sep=0pt]
\definecolor{dg}{rgb}{0,0.3,0}
\path[draw=black,line join=miter,line cap=butt,line width=0.800pt, fill=gray]
  (231.3249,143.2249) .. controls (178.0814,153.1889) and (178.5527,172.4247) ..
  (180.8173,200.8036) .. controls (183.2959,231.8645) and (195.6610,188.6038) ..
  (256.5787,230.0980) .. controls (295.8993,256.8813) and (346.4296,308.3911) ..
  (295.9747,178.5802) .. controls (275.5517,126.0356) and (304.8066,129.4735) ..
  (231.3249,143.2249) -- cycle;
\node at (230,180) {Obstacle};
\path[dashed,draw=dg,line join=miter,line cap=butt,line width=1.5pt]
  (88.8934,277.5752) .. controls (196.3490,276.5363) and (532.8532,213.7494) ..
(434.3656,81.6056) node [above = 0.1cm, color=dg, text width=1.8cm] {\small{Constrained manifold $\manifold$}};
\node [draw,circle,inner sep=2pt,fill = gray] (qn) at (97,277) {};
\node [above = 0.15cm] at (qn) {\config{near}};
\node [draw,circle,inner sep=2pt] (qr1) at (367,99) {};
\node [left = 0.2cm] at (qr1) {\config{rand}};
\draw [dashed,thin] (qn) -- (450,277);
\node [right = 0.2cm] at (450,277) {\small{$T_{\mathbf{q}}\manifold$}};
\node [draw,circle,inner sep=2pt] (qr2) at (367,277) {};
\node [below right = 0.1cm] at (qr2) {\config{rand}$'$};
\node [draw,circle,inner sep=2pt,fill = gray] (qr3) at (345,225) {};
\node [above = 0.22cm] at (qr3) {\config{rand}$''$} ;
\draw [dashed,thin] (qr1) -- (qr2) -- (qr3);
\node [draw,circle,inner sep=2pt,fill = gray] (qnew) at (270,250) {};
\node [above = 0.1cm, left = 0.2cm] at (qnew) {\config{new}};
%\draw [thick] (qn) -- (qnew);

\end{tikzpicture}
\end{minipage}
\begin{minipage}[c]{0.3\linewidth}
%% \begin{tikzpicture}[x=0.61cm,y=0.61cm]
%%    \definecolor{dg}{rgb}{0,0.3,0}
%%       %Stack of tasks:
%%       \draw [color=black, thick,fill = white] (0,1) rectangle (2,2);
%%       \draw [color=black, thick,fill = white] (0,2) rectangle (2,3);
%%       \draw [color=black, thick,fill = white] (0,3) rectangle (2,5);
%%       \draw [color=black, thick,fill = white] (0,5) rectangle (2,6);
%%       \draw [color=black, thick,fill = white] (0,6) rectangle (5,7);
%%       \draw [color=black, thick,fill = white] (1,1) rectangle (5,6);
%%       \draw [thick] (1,1) -- (5,1) -- (5,6);
%%       \draw (1,2) -- (5,2) ;
%%       \node [text width = 5cm,text centered] at (2.5,6.5) {\large Stack
%%         of tasks};
%%       \begin{scriptsize}
%%         \node at (0.5,5.5) {1};
%%         \node at (0.5,4) {$\vdots$}; 
%%         \node at (0.5,2.5) {$n$};
%%         \node at (0.5,1.5) {$n$+1};

%%         \node [text width = 2cm,color=dg] at (3.2,4) {\small Constraints defining
%%           $\manifold$};
%%         \node [text width = 3cm,text centered] at (3,1.5)
%%               { Configuration task towards \config{rand}};    
%%       \end{scriptsize}

%% \end{tikzpicture}
\end{minipage}

\caption{One step of constrained extension illustrating Algorithm
  \ref{alg:constrained}: \config{rand} is first projected on
  $T_{\mathbf{q}}\manifold$ the tangent space of
  $\manifold$. \config{rand}$'$ is then projected onto $\manifold$ at
  \config{rand}$''$. A classic RRT extension tries to go as far as
  possible from \config{near} towards \config{rand}$''$ while
  remaining on $\manifold$. \config{new} is then returned.}
\label{fig:gikrrt}
\end{figure}

\begin{algorithm}
  \caption{\texttt{ConstrainedExtend}($\mathcal{T},$\config{near}$,$\config{rand}$,f,\epsilon$)}
  \label{alg:constrained}
  \begin{algorithmic}
    \STATE $d \leftarrow$ \texttt{Distance}(\config{near}$,$ \config{rand})
    \STATE $q \leftarrow$ \config{near}
    \WHILE{$d > \epsilon$}
    \STATE \config{rand}$' \leftarrow$ \texttt{OrthogonalProject}(\config{rand}$, T_q\manifold$)
    \STATE \config{rand}$'' \leftarrow$ \texttt{SolveConstraints}(\config{rand}$',f,\epsilon$)
    \STATE $d \leftarrow$ \texttt{Distance}(\config{}$,$\config{rand}$''$)
    \STATE \config{}$ \leftarrow $\config{rand}$''$
    \ENDWHILE
    \STATE \config{new}$ \leftarrow$ RRT::Extend($\mathcal{T},$\config{near}$,$\config{rand}$''$)
  \end{algorithmic}
\end{algorithm}
    
\subsection{Example}

We present in Figure~\ref{fig:wb-shelves} an illustration of the use
of randomized motion planning on complex manipulation problems. The
humanoid robot HRP-2 faces shelves. It has to: (i) grasp a ball lying
on a shelf, (ii) put it on a higher shelf, (iii) come back to a
natural rest configuration. We can thus define three separate
constrained motion planning problems where the planning manifold
$\manifold$ is the static balance manifold defined in
\ref{subsec:chap2-constraint-motion-planning}; the goal manifold of
problem (i) is defined by a hand pose constraint (the hand must be
horizontal and its position has to coincide with the ball initial
position), and a gaze constraint (the robot has to look at the ball in
its initial position). Similarly, the goal manifold of problem (ii) is
defined by hand and gaze constraints that correspond to the position
of the ball on the higher shelf. Finally, we define the rest
configuration as the single goal configuration for problem (iii).

The goal configuration in phase (i) is in a narrow passage. Note that
for phases (i) and (iii) the ball is also considered as an
obstacle. This is necessary to prevent the robot grasping hand from
colliding with the ball during the approach and retraction phase.

For the two reaching motions in (i) and (ii), we first generate 8
random goal configurations
(Section~\ref{subsubsec:chap2-goal-sampling}), then we solve the three
constrained motion planning problems separately. As randomized motion
planning algorithms produce log paths, a classic shortcut method is
used to optimize and shorten them.

This set of motion planning problems was run 20 times; results are
compiled in Table~\ref{table:reaching}. The performance of
\texttt{SolveConstraints} (Algorithm \ref{algo:newton}) is also
measured when used to project configurations on $\manifold$; the
average number of iterations is 6.5 per call, and the success rate,
i.e. the ratio of the number of successfully projected configurations
over the total number of calls, is above 95 percent. This success
rate, high as it is, could be further improved by sampling a better
initial configuration of {\cspace}, for example by introducing a
heuristic bias towards statically balanced configurations.

\begin{figure}
\centering
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/wb-shelves/1.jpg}
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/wb-shelves/2.jpg}
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/wb-shelves/3.jpg}
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/wb-shelves/4.jpg}
\\
\vskip 0.08cm
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/wb-shelves/5.jpg}
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/wb-shelves/6.jpg}
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/wb-shelves/7.jpg}
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/wb-shelves/8.jpg}

\caption{HRP-2 grabs a ball on a shelf, puts it on another shelf, and
  comes back to a rest position. Static balance constraints are
  enforced along the path, and the intermediary goals consisting in
  grasping and displacing the ball are defined implicitly as inverse
  kinematics constraints.}
\label{fig:wb-shelves}
\end{figure}

\begin{table}
\begin{tabular}{l|r|r|r|r|}
\cline{2-5}
& min & max & average & average \\ 
&&&& per problem \\
\hline
\multicolumn{1}{|l|}{number of nodes} & 43.00 & 481.00 & 102.70 \\
\cline{1-4}
\multicolumn{1}{|l|}{goal generation time (s)} & 1.00 & 1.56 & 1.22\\
\hline
\multicolumn{1}{|l|}{planning time (s)} & 67.36 & 376.84 & 134.28 & 44.76\\
\hline
\end{tabular}
\caption {Experimental results on 20 runs: Each run consists of 3
  motion planning problems and 2 goal generations for the three
  phases. Time is expressed in seconds.}
\label{table:reaching}
\end{table}

\subsection{Extension to Collision-Free Walk Planning}
\label{subsec:chap2-constraint-walk-planning}

While the previous algorithm considers motion planning on a single
submanifold $\manifold$ of {\cspace}, similar strategies can be adopted
to explore the union of submanifolds $\cup\manifold_{i}$ and achieve
quasi-static multi-step planning for walking and free-climbing robots,
see \cite{bretl2006motion, haus10}. These methods can
be seen as very generic and offer the property of probabilistic
completeness; they are not however directly applicable to humanoid
dynamically balanced locomotion.

Other recent contributions to the field of locomotion planning include
algorithms considering the dynamics at the planning phase
\cite{glassman2010quadratic, shkolnik2011bounding}. This leads to a
growth of algorithmic complexity, particularly costly for
high-dimensional systems such as humanoid robots, which can explain
why such techniques have not yet been used on humanoid robotic
platforms so far.

\section{From Geometric Paths to Feasible Motions: Small-Space Controllability}
\label{sec:ssc} 

Let us recalls the definition of small-space controllability and its
use in motion planning.

A robotic system is controllable if for any two configurations \config{1}
and \config{2}, there exists a trajectory going from \config{1} to \config{2}.  It is
\textit{small-space controllable} if for all configurations \config{}, for
all $\epsilon >0$, there exists $\eta >0$ such that all the
configurations contained in the ball of center \config{} and radius $\eta$
are reachable by trajectories included in the ball of center \config{} and
radius $\epsilon$. Figure~\ref{fig:ssc1} shows an illustration of this
property.

\begin{figure}
  \centering
  \input{stc1.tex}

  \caption{The small-space controllability local property:  any configuration $q'$ 
    at a distance less than
    $\eta$ is reachable from \config{} by an admissible trajectory included in
    a ball of size $\epsilon$.}
  \label{fig:ssc1}
\end{figure}

The main consequence of this property in motion planning is the
following theorem, that shows how planning for dynamic systems is
reduced to geometric planning thanks to the small-space
controllability property:

\begin{theorem}
  \label{thm:ssc}
  Any collision-free path of a small-space controllable system can be approximated
  by a sequence of both collision-free and admissible trajectories. Thus, small-space 
  controllability reduces trajectory planning problems to geometric path planning problems.
\end{theorem}

Figure \ref{fig:ssc2} shows an example of collision-free path
approximation by admissible collision-free sub-trajectories. The
convergence of this algorithm is guaranteed by the small-space
controllability property.

\begin{figure}
  \centering

  \input{stc2.tex}

  \caption{Small-space controllability in motion planning. 
    A collision-free path from
    \config{1} to \config{2} is approximated by collision-free and admissible
    trajectories by using the local property.
  }
  \label{fig:ssc2}
\end{figure}

This result has been long known and used in motion planning, in
particular for non-holonomic systems. A detailed proof can be found in
\cite{taix-94}. We present a sketch of the proof to give an intuition
about the corresponding algorithm.

\begin{proof}[Proof of Theorem \ref{thm:ssc}]
  Let {\cspace} be the configuration space of a small-space
  controllable robot, and {\cfree} $\subset$ {\cspace}
  the set of collision-free configurations. We consider in-contact
  configurations as colliding, so {\cfree} is an open set.
  Let $\tau : [0,1] \rightarrow $ {\cfree} be a collision-free
  path. Thus for all $x \in [0,1]$, $\tau(x) \in $ {\cfree},
  there exists $\epsilon_x$ such that the open ball
  $B(\tau(x),\epsilon_x)$ of center $\tau(x)$ and radius $\epsilon_x$
  is included in \cfree. The small-space controllability property
  states that for all $x$, there exists $\eta_x > 0$ such that every
  configuration $q \in B(\tau(x),\eta_x)$ is reachable from $\tau(x)$
  by a trajectory included in $B(\tau(x),\epsilon_x)$.

  The set of open balls $\left( B(\tau(x),\eta_x) \right)_{x\in
    [0,1]}$ forms an open cover of $\tau([0,1])$ which is compact. The
  Heine-Borel theorem \cite{fitzpatrick2006advanced} states that there
  exists a finite subcover $\left( B(\tau(x_i),\eta_{x_i})
  \right)_{i\in \{ 1,\dots ,n \}}$ of $\tau([0,1])$. To this finite
  subcover corresponds a finite number of feasible trajectories, going
  from $\tau(0)$ to $\tau(1)$, included in the union of $\left(
  B(\tau(x_i),\epsilon_{x_i}) \right)_{i\in \{ 1,\dots ,n \}}$, and
  thus in \cfree. This concludes the proof.
\end{proof}

\subsubsection{Small-Time \textit{versus} Small-Space Controllability}
In the control theory literature, the property used is usually
\textit{small-time controllability}, which states that for all
configurations \config{}, for all times $T>0$, the set of configurations
accessible from \config{} in time less than $T$ forms a neighborhood of
\config{}. When accelerations and velocities are bounded, small-time
controllability implies small-space controllability. This is why a lot
of motion planning previous work only refers to the sufficient
small-time controllability property. However, the reciprocate is not
necessarily true: a system can be small-space controllable and not
small-time, if the trajectories generated by its controller are
arbitrarily long.  The important property, regarding motion planning
application, is small-space controllability, as Theorem~\ref{thm:ssc}
shows. In the following, we show that legged robots are small-space
controllable, but not that they are small-time controllable.  In fact,
the control method that we present does not follow the small-time
controllability property. For the sake of clarity, we have chosen to
make the distinction between these two controllability properties.

\section{Contribution}
\label{chap2-contribution}

The main contribution of this chapter is a whole-body motion planner
for humanoid robots that computes collision-free walking trajectories,
based on exact models of both robot and environment. It is used to
solve manipulation tasks that may require walking. The first stage of
our algorithm uses a sampling-based constrained motion planner and
computes a collision-free statically balanced path for a robot which
can be fixed or sliding on the ground.

Another contribution of this chapter is the formal proof that dynamic
walking makes humanoid robots small-space controllable, with the
direct implication that this first path can always be approximated by
a dynamically balanced, collision-free walking trajectory. We have
implemented this well-grounded method, and the results have been
validated on the HRP-2 robot.

Section~\ref{sec:wb-step} generalizes the constrained motion planning
algorithm to problems that require locomotion. The generalization is
well-grounded, and based on a controllability property of legged
robots demonstrated in the chapter. Section~\ref{sec:exp} presents
some experimental results, and Section~\ref{sec:limits} discusses the
limitations and potential future work of our method.

\section{From Statically Balanced Paths to Dynamic Walk Trajectories}
\label{sec:wb-step}

The previous section has presented a simple algorithm that solves
manipulation planning problems on a given constraint manifold
$\manifold$ of {\cspace}. If we use this algorithm with static balance
constraints without fixing globally the robot foot positions, it
generates statically balanced paths for a robot \textit{sliding} on
the ground. Fig~\ref{fig:sliding} shows an example of a whole-body
collision-free path for a robot passing between two chairs. Since in
reality a legged robot cannot slide on a regular floor, such paths are
physically unfeasible. They are, however, easier to generate than
feasible dynamic walking trajectories because only geometric
constraints are considered at planning time.

\begin{figure}
  \centering

  \includegraphics[width=0.24\linewidth]
                  {src/chap2-wholebody-planning/pics/chairs/sliding-perspective-1.png}
  \includegraphics[width=0.24\linewidth]
                  {src/chap2-wholebody-planning/pics/chairs/sliding-perspective-2.png}
  \includegraphics[width=0.24\linewidth]
                  {src/chap2-wholebody-planning/pics/chairs/sliding-perspective-3.png}
  \includegraphics[width=0.24\linewidth]
                  {src/chap2-wholebody-planning/pics/chairs/sliding-perspective-4.png}
  \caption{Collision-free  statically balanced path  for a  humanoid  robot  sliding on  the
    ground.}
  \label{fig:sliding}
\end{figure}

This section presents a \textit{constructive} proof that any such
statically balanced, collision-free path for a legged robot sliding on
the ground can be approximated by a dynamically balanced,
collision-free walk trajectory.  The proof is based on ideas from
control theory, in particular small-space controllability. It also
uses the fact that balance criteria for dynamic walking are different
from the ones for static balance.

Section~\ref{sec:humanoid-ssc} proves that a dynamically walking
legged robot is small-space controllable, while a quasi-statically
walking legged robot is not. Section~\ref{sec:ssc-application} shows
how this property is used to approximate collision-free statically
balanced paths by dynamic walking trajectories.

\subsection{Dynamic Walking Makes Humanoid Robots Small-Space Controllable}
\label{sec:humanoid-ssc}

This section discusses a walking robot small-space controllability. To
clarify the presentation, we consider a simplified model of a legged
robot consisting of two feet of zero mass and a point mass free to
move in three dimensions.  We do not consider the kinematic chains
between the feet and the mass. The robot is walking on a flat terrain,
and the feet are assumed to have a positive surface. For our
presentation, it is not necessary to consider the foot height, so the
configuration space of the robot is:
\begin{equation}
  \mathcal{CS} = SE(2) \times SE(2) \times \mathbb{R}^3
\end{equation}
It is of dimension 9.

The balanced walking conditions for a quasi-static walking robot are
that the point mass, or CoM, should always be over the support polygon
(the convex hull of the two feet), and one foot can move iff the CoM
is over the other foot. Similarly, the walking conditions for a
dynamic walking robot are that the ZMP should always be in the robot
support polygon, and one foot can move iff the ZMP is over the other
foot. Under these assumptions, the following result holds:

\begin{theorem}
\label{thm:humanoid-ssc}
A quasi-statically walking robot is not small-space controllable. A
dynamically walking robot is.
\end{theorem}

\begin{proof}[Proof of Theorem \ref{thm:humanoid-ssc}]

The first claim is straightforward. Let the robot be in a
configuration \config{} where the two feet are separated by a positive
distance. Let $L>0$ be the positive horizontal distance between the
CoM and the left foot (if the CoM is over the left foot, we can
consider similarly the right foot). For all $\epsilon < L$, any valid
trajectory starting from \config{}, included in the ball of center
\config{} and radius $\epsilon$, is such that the CoM is never over
the left foot.  Given the quasi-static walking conditions, the right
foot of the robot is fixed along the trajectory. Thus, the set of
accessible configurations from \config{} by staying inside
$B($\config{}$,\epsilon)$ does not form a neighborhood of \config{},
since it does not include any configuration where the right foot has
moved. This shows that the robot is not small-space controllable.

\bigskip

Let us now consider a dynamically walking robot. Starting from any
valid static configuration, the CoM can move vertically without
affecting balance, so there is no need to consider this degree of
freedom in the following. If the CoM is not over the edge of the
support polygon, it is possible to move it in a quasi-static way
inside a neighborhood of its current position that projects itself
over the support polygon.  It is thus sufficient and necessary to
prove that for all $\epsilon >0$, it is possible to move the feet
while keeping the CoM inside a neighborhood of size $\epsilon$. Let
such $\epsilon >0$ be arbitrarily fixed.

Let us recall the equations giving the ZMP horizontal coordinates
$(p_x,p_y)$ as functions of CoM horizontal coordinates $(x,y)$ in the
cart-table model, as presented in Section
\ref{subsec:chap1-cart-table}:
\begin{equation}
\label{eq:walk-zmp}
\left(
\begin{array}{c}
p_x\\ p_y
\end{array}
\right) = \displaystyle \left(
\begin{array}{c}
x - \frac{z_c}{g} \ddot{x}\\ y - \frac{z_c}{g} \ddot{y}
\end{array}
\right)
\end{equation}
where $z_c$ is  the constant height of the CoM and  $g$ is the gravity
constant.    In    the    following    we    will    note    $\omega_0
=\sqrt{\frac{g}{z_c}}$.

Without loss of generality, let us assume that the robot is in a
configuration in which the CoM is at the horizontal position $(0,0)$,
the foot centers are aligned with the $y$-axis and the horizontal
distance between the CoM and either of the foot centers is $L$. To
achieve dynamically balanced walking, we aim at making $p_y(t)$
oscillate between $-L$ and $L$. To move the ZMP under a given foot,
only the $y$ coordinate of the CoM is of interest. Thus, we will keep
the $x$ coordinates of the CoM and ZMP constant equal to $0$. By
assumption, the feet have a positive surface, let $l>0$ be such that
the length of the section of a foot along the $y$-axis is greater than
$l$. Figure~\ref{fig:simple-humanoid} summarizes the notations used in
the following.

\begin{figure}
  \centering
  \input{humanoid.tex}

  \caption{Simplified model of a legged robot. The CoM is at
    $(0,0,z_c)$, the two feet are flat on the ground, aligned with the
    $y$-axis, at a horizontal distance $L$ from the CoM.}
  \label{fig:simple-humanoid}
\end{figure}

The idea of this proof is to use the form of Eq. (\ref{eq:walk-zmp})
to apply a scaling factor between the amplitude of the oscillations of
the CoM and of the ZMP. The faster the CoM oscillates, the bigger is
the amplitude of the ZMP oscillations. Following is a formalization of
this idea.

For $\omega >0$, assuming the CoM follows the trajectory
$y(t) = \epsilon \sin(\omega t)$,  Eq. (\ref{eq:walk-zmp}) gives:
\[
p_y(t) = (1+\left(\frac{\omega}{\omega_0}\right)^2)\epsilon\sin(\omega
t)
\]

The amplitude of the oscillations of $y$ is multiplied by a factor
$(1+\left(\frac{\omega}{\omega_0}\right)^2)$.  Choosing $\omega =
\omega_0 \sqrt{\frac{L}{\epsilon} -1}$ makes $p_y$ oscillate between
$-L$ and $L$, while $y$ oscillates between $-\epsilon$ and $\epsilon$.
At time $t_l^{(n)} = n\frac{2\pi}{\omega} + \frac{\pi/2}{\omega}$, the
ZMP is located at the center of the left foot, the robot can move its
right foot and at time $t_r^{(n)} = n\frac{2\pi}{\omega} +
\frac{3\pi/2}{\omega}$ the ZMP is located at the center of the right
foot, the robot can move its left foot.

Starting from a static configuration at time $(t=0)$, we cannot apply
directly a control $y(t) = \epsilon \sin(\omega t)$ because it
generates a discontinuity in the speed of the CoM at time $(t=0)$. To
overcome this discontinuity, we go through a transient state between
$(t=0)$ and $(t=T)$ for some $T >0$. Let $f:[0,T] \rightarrow [0,1]$
be an increasing function of class $C^\infty$ such that $f(0) = 0$,
$\dot{f}(0) = 0$, $f(T) = 1$, $\dot{f}(T) = 0$ and $\ddot{f}(T) = 0$.
We can explicitly construct such an $f$ with a spline of degree 4.  We
also request that for all $t \in [0,T]$,
$|2\epsilon\dot{f}(t)\frac{\omega}{\omega_0^2}| \leq \frac{l}{4}$ and
$|\epsilon\ddot{f}(t)/\omega_0^2| \leq \frac{l}{4}$.  These
inequalities will be used to bound the trajectory of the ZMP. We can
guarantee them by choosing $T$ large enough. Let us now consider the
following CoM motion:

\[
y(t) = \left\{
\begin{array}{ll}
f(t)\epsilon\sin(\omega t) 
& \text{if } t\in [0,T]
\\ 
\epsilon\sin(\omega t) 
& \text{if } t \geq T \end{array}
\right.
\]

One can check that $y$ is of class $C^2$ over $\mathbb{R}_+$, and that
$\dot{f}(0) = 0$. When $t\geq T$, the robot is in the permanent state
described above and can successively move either of its feet inside
small neighborhoods.  The last point to check is that for $t \in
[0,T]$ $p_y(t)$ stays inside the support polygon of the robot. The
calculation of the successive derivatives of $y$ gives:

\[
\begin{array}{cl}
p_y(t) = &  f(t) \epsilon (1 + \left(\frac{\omega}{\omega_0}\right)^2)
\sin (\omega  t) \\ &  + 2\epsilon \dot{f}(t)\frac{\omega}{\omega_0^2}
\cos  (\omega t)  \\ &  +  \frac{\epsilon}{\omega_0^2}\ddot{f}(t) \sin
(\omega t)
\end{array}
\]

\begin{figure}
\centering
\input{fig-zmp-inplace.tex}

\caption{CoM motion (solid line) along $y$ axis.  The CoM stays in the
  interval $[-\epsilon,\epsilon]$ while during permanent state ($t
  \geq T$), the ZMP (dashed line) oscillates between the centers of
  the feet, which allows in-place walk.}
\label{fig:zmp-inplace}
\end{figure}

For all $t \in [0,T]$, $f(t) \epsilon (1 + \frac{\omega}{\omega_0}^2)
\sin (\omega t)$ lies between $-L$ and $L$. The bounds on the
derivatives of $f$ guarantee that $p_y(t)$ lies between $-L- l/2$ and
$L+ l/2$, which means that the ZMP stays inside the support polygon.
Figure  \ref{fig:zmp-inplace} shows an example of CoM motion on the $y$
axis and the corresponding ZMP motion. Once in permanent in-place
walking state, the robot can come back to a static state by applying a
symmetric transient state used to decrease gradually the amplitude of
the oscillations of the CoM without generating a discontinuity in the
first derivative of the control.

We have thus exhibited a continuous control scheme that allows to move
any of the feet in any direction, while keeping the CoM inside an
arbitrarily small neighborhood. This concludes the proof.
\end{proof}

\subsubsection{Remarks}
\paragraph{Generalization to a complete model:} 
We did not extend the previous proof to any legged robot model since
empirically, the table cart model is a very good fit for our humanoid
robot. Although of little practical interest, the generalization of
the proof does not seem very difficult to achieve. As an insight, the
difference between the table cart model and the full size humanoid
robot is due to the derivative of the angular momentum and to the
vertical acceleration of the center of mass. These perturbations can
be made as small as desired along the sliding path by following the
sliding path as slowly as necessary. The derivatives of the angular
momentum produced by the stepping motion can also be made as small as
desired by making the step height as small as necessary and by using
recent results on properties of joint trajectories induced by
end-effector motions \cite{Zanchettin6084763}.

\paragraph{Use of ZMP preview controller:}
The control strategy presented in the previous proof may generate very
long trajectories, because of the transient states at the beginning
and end of the locomotion. In the actual implementation, we have
chosen to generate CoM motions with a ZMP preview controller, as
presented in \cite{kaji03}.  We have observed experimentally that the
amplitude of CoM trajectories decreases when the frequency of steps
increases. Our current ZMP preview controller relies on the cart-table
model approximation.  To make this approximation valid, we fix the
height of the robot CoM during walk, as well as the vertical
orientation of the robot waist. These geometric constraints are also
applied when planning statically balanced paths, to ensure that the
paths can be approximated by dynamic walk trajectories. Note that this
is due to our current ZMP preview controller implementation, and does
not affect the generality of the small-space controllability result
presented above.

Relying on the cart-table model approximation means that the angular
momentum induced by arm movements for instance can lead to non
dynamically balanced walking motion. We thus implement the ZMP
filtering stage proposed in \cite{kaji03} to compute the exact ZMP,
take into account the full dynamics of the robot and generate feasible
trajectories.

\paragraph{Speed of CoM:}
The theoretical result presented in this section implies that any
collision-free path can be approximated by a sequence of admissible
and collision-free trajectories. However, the theorem depends on a
control law that generates trajectories with unbounded velocities for
the CoM, when the input path is close to obstacles. The humanoid robot
hardware may be a limitation to such trajectories. To prevent the
generated CoM oscillations from being too fast, one has to require
that the statically balanced path is included inside an
$\epsilon$-radius tube of the free space, where $\epsilon$ depends on
the physical capacities of the robot.

\subsection{Application: Dynamic Approximation of a Statically Balanced Sliding Path}
\label{sec:ssc-application}

The algorithm that animates a statically balanced path into a
dynamically balanced walk trajectory has been inspired by the previous
small-space controllability proof. Given a statically balanced path
$P$ verifying the cart-table model approximation constraints, we start
by placing footprints corresponding to the nominal walk pattern of the
robot. Given the footprints, we compute a ZMP trajectory, derive foot
trajectories, and a preview controller returns the corresponding CoM
trajectory. Classic numerical Jacobian-based prioritized inverse
kinematics methods prove to be very useful to generate a dynamic
walking trajectory while trying to accomplish secondary tasks, such as
following a reference configuration trajectory. We use the framework
called Generalized inverse kinematics (Gik) and developed in
\cite{yoshida2006tds}.

The hierarchy of tasks (referred to as \textit{GikTasks} in Algorithm
~\ref{alg:walk}) applied to the robot to generate a dynamic walking
motion is -- in decreasing priority order:

\begin{enumerate}

\item Positions and orientations of  feet,

\item Horizontal position of the CoM,

\item Height of the CoM,

\item Verticality of the waist,

\item Configuration task towards corresponding
  configuration  in $P$.

\end{enumerate}

Tasks (1) and (2) generate a dynamically balanced motion by using the
simplified cart-table model and the ZMP criterion. Tasks (3) and (4)
ensure that the resulting motion is well described by the cart-table
model. Task (5) is used to approximate $P$ as well as possible given
the walk parameters.

Because it comes at the  lowest priority, task (5) is not necessarily
fulfilled in  the resulting trajectory. Hence,  collisions may appear
when animating $P$, if the resulting trajectory diverges too much from
the initial sliding  path. If so, it is  necessary to approximate more
closely $P$  by a walk  trajectory.  To do  so, we use  the small-space
controllability  property   of  the  system  shown   in  the  previous
section. The way  we use this property is  inspired by similar results
in non-holonomic mobile robot control presented in \cite{taix-94}.

If the animated  trajectory collides with the environment,  we cut the
initial  path   $P$  into  two   sub-paths,  that  we  try   to  animate
recursively. When the  paths to animate are too  short for the robot
nominal  walk parameters, we  accelerate the  steps, and  decrease the
maximum height of  the moving foot. As shown  in previous section, the
walk trajectory  corresponding to  smaller and faster  steps converges
toward the  sliding path.  Algorithm ~\ref{alg:walk} shows pseudo-code
that takes  a sliding path $P$  as input and  returns a collision-free
walk trajectory.

\begin{algorithm}
\caption{FindDynamicTrajectory(Path $P$)}
\label{alg:walk}
\begin{algorithmic}
\STATE $Footprints \leftarrow \text{ComputeFootprints}(p)$

\STATE $GikTasks$.addFootprintTask($Footprints$)

\STATE $GikTasks$.addWaistTask()

\STATE $GikTasks$.addConfigurationTask($P$)

\STATE $DynamicTrajectory \leftarrow
\text{ComputeWalkTrajectory}(GikTasks)$

\IF{(CheckForCollisions($DynamicTrajectory$) = Colliding)}

\STATE $(p_1,p_2) \leftarrow \text{CutInHalf}(p)$

\STATE $DT_1 \leftarrow \text{FindDynamicTrajectory}(p_1)$

\STATE $DT_2 \leftarrow \text{FindDynamicTrajectory}(p_2)$

\RETURN $\text{Concatenate}(DT_1,DT_2)$

\ELSE

\RETURN $DynamicTrajectory$

\ENDIF
\end{algorithmic}
\end{algorithm}

\section{Experimental Results}

\label{sec:exp}

The motion planning algorithms presented in this chapter have been
implemented using KineoWorks\texttrademark \cite{laumond2006kcs}. The
planning times have been measured on an Intel Core~2~Duo 2.13~GHz PC
with 2~GB of RAM. Evaluation of the randomized algorithm has been
conducted by executing 500 trials on each scenario using two flavors
of RRT: the classic RRT and IPP-RRT \cite{FERR04A}. We present the
results in Figures \ref{fig:rrt-it}, \ref{fig:rrt-t} and \ref{fig:rrt-n}
in Appendix \ref{chap:app-sliding}.

Our whole-body motion planner generates a robot configuration
trajectory that is sampled at a 200~Hz rate and stored in a file. This
file can then be used to play the trajectory in open-loop on the HRP-2
robot, which is position-controlled. Scenarios in Sections
\ref{sec:chairs} and \ref{sec:shelf} were both successfully executed.

To get more natural motions in the experiments, we require the foot
positions to be fixed with respect to each other, and the CoM to be
projected in the center of the support polygon during the sliding path
planning stage.

\subsection{Passing between two chairs}
\label{sec:chairs}

\begin{figure}
\centering
\includegraphics[width=0.6\linewidth]
                {src/chap2-wholebody-planning/pics/chairs/couv.png}
\caption{The robot HRP-2 passing between two chairs. In this kind of
  environment whole-body collision avoidance is needed during
  locomotion.}
\label{fig:couv}
\end{figure}

The environment shown in Figure \ref{fig:couv} and \ref{fig:sliding}
was presented in Section \ref{subsec:chap1-chairs}. There, the motion
planning problem is solved with a bounding box method, leading the
robot to walk sideways between the two chairs. The method presented in
this chapter generates a locomotion trajectory in which the robot
walks forward, which may be required if the robot has to use vision
during locomotion. The first planning stage requires 1~s on average.
The animation of the sliding path presented in Figure
\ref{fig:sliding} uses 66.5~s of computation time.

\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]
                {src/chap2-wholebody-planning/pics/chairs/waist-trajectory.png}

\caption{Horizontal trajectory of the robot CoM during
  locomotion. When the robot is close to obstacles, the amplitude of
  the oscillations decreases.}
\label{fig:chairs-waist}
\end{figure}

Figure  \ref{fig:chairs-waist} shows the horizontal trajectory of the
robot CoM during locomotion. The amplitude of the oscillations
decreases when passing between the chairs.  This motion has been
validated on a real HRP-2 platform.

\subsection{Walking among floating obstacles}

\begin{figure}

\centering

\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/objects-cloud/perspective-1.png}
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/objects-cloud/perspective-2.png}
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/objects-cloud/perspective-3.png}
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/objects-cloud/perspective-4.png}
\\ 
\vskip 0.08cm
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/objects-cloud/perspective-5.png}
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/objects-cloud/perspective-6.png}
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/objects-cloud/perspective-7.png}
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/objects-cloud/perspective-8.png}

\caption{Solution path for a cluttered environment, the robot walks
  among floating obstacles.}
\label{fig:cluttered}
\end{figure}

In the environment shown in Figure \ref{fig:cluttered}, the robot has to
find a way among floating obstacles. In this environment neither
bounding box nor footstep planning strategies could find a
collision-free walk trajectory.  The first planning stage requires
53~s on average, and the animation of the trajectory presented in
Figure~\ref{fig:cluttered} uses 339.5~s of computation
time. Figure~\ref{fig:cluttered-waist} shows the robot CoM trajectory
during locomotion.

\begin{figure}
  \centering
  \includegraphics[width=0.7\linewidth]
                  {src/chap2-wholebody-planning/pics/objects-cloud/waist-trajectory.png}

  \caption{Horizontal trajectory of the robot CoM during
    locomotion.}
  \label{fig:cluttered-waist} 
\end{figure}


\subsection{'Put the ball on a shelf'}
\label{sec:shelf}

In the problem shown in Figure \ref{fig:shelf} the robot has to put a
ball on a shelf, in a constrained apartment environment. The final
configuration is defined implicitly as a desired hand position. We
have generated automatically goal configurations solving the task, as
described in Section~\ref{subsec:chap2-constraint-motion-planning}
. Then, we have applied our planner to generate a whole-body walking
motion that solves the hand reaching task.

The solution sliding path is constrained between the table on the
right and the lamp on the left. This passage is too narrow for the
robot nominal walk parameters.  When executing the walk motion
resulting from our algorithm, the robot left hand is only a few
centimeters away from the lamp.

The first planning stage requires 15~s on average, and the animation
of the resulting walk motion presented in Figure~\ref{fig:shelf}
requires around 190~s of computation
time. Figure~\ref{fig:shelf-waist} shows the robot CoM trajectory
during locomotion. Figure~\ref{fig:shelf-cdf} shows some snapshots
taken from the motion execution on the real robot HRP-2.

\begin{figure}
\centering
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/shelves/trajectory-1.png}
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/shelves/trajectory-2.png}
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/shelves/trajectory-3.png}
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/shelves/trajectory-4.png}
\\ 
\vskip 0.1cm
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/shelves/trajectory-5.png}
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/shelves/trajectory-6.png}
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/shelves/trajectory-7.png}
\includegraphics[width=0.24\linewidth]
                {src/chap2-wholebody-planning/pics/shelves/trajectory-8.png}

\caption{Solution path for a hand reaching problem in an
  apartment. The goal is implicitly defined as an inverse kinematics
  task.} 
\label{fig:shelf}
\end{figure}

\begin{figure}
\centering

\includegraphics[width=0.4\linewidth]
                {src/chap2-wholebody-planning/pics/shelves/waist-trajectory.png}

\caption{Horizontal trajectory of the robot CoM during
    locomotion.}
\label{fig:shelf-waist}
\end{figure}

\begin{figure}
\centering

\includegraphics[width=0.19\linewidth]
                {src/chap2-wholebody-planning/pics/shelves-cdf/1.jpg}
\includegraphics[width=0.19\linewidth]
                {src/chap2-wholebody-planning/pics/shelves-cdf/2.jpg}
\includegraphics[width=0.19\linewidth]
                {src/chap2-wholebody-planning/pics/shelves-cdf/3.jpg}
\includegraphics[width=0.19\linewidth]
                {src/chap2-wholebody-planning/pics/shelves-cdf/4.jpg}
\includegraphics[width=0.19\linewidth]
                {src/chap2-wholebody-planning/pics/shelves-cdf/5.jpg}

\caption{Execution of the walking trajectory by HRP-2 on stage. The
  robot first goes to the shelves to release the ball, then comes back
  to a rest position.}

\label{fig:shelf-cdf}
\end{figure}

\section{Discussion and Future Work}
\label{sec:limits}

This section lists some limitations of the current methods, and
discusses potential future work to overcome them.

\subsection{Stepping over obstacles}

Because of the kinematic constraints we apply at the planning stage,
we are not able yet to plan motions where the robot steps over
obstacles, while this is an important feature of humanoid
robots. Nevertheless, because we compute collision queries on an exact
model of the robot, our method is able to generate paths where
obstacles pass between the feet of the robot.  In future work, we plan
to develop mixed methods, where collision avoidance at the leg level
can be solved by footstep planning techniques, while whole-body
collision-avoidance can be solved by the algorithm presented in this
chapter.

\subsection{Environment representation}

The experimental setup assumes perfect knowledge of the
environment. This can be guaranteed during experiments by using
calibrated objects and motion capture systems. This indeed allows us
to focus on complex motion planning problems. The perception problem,
interesting as it is, is thus completely decoupled from the planning
problem in our presentation. From previous experiences however, we are
confident that our algorithm will work as well in environments modeled
by vision \cite{Nakhei4755945,DanLauLam2012}.

\subsection{Trajectory following}

The setup also assumes perfect execution of the plan. It can be
critical here, since non-nominal stepping may cause the robot to drift
away from the planned trajectory. Future experiments will include
trajectory following during plan execution.

\section{Conclusion}

In this chapter, we have used a simple algorithm for constrained
motion planning within a novel, well-grounded strategy for humanoid
whole-body manipulation planning including locomotion. The locomotion
algorithm is based on a formal small-space controllability property of
humanoid robots. An important point is that this strategy only holds
for dynamic walking robots, and not for quasi-static walking ones. We
have used our motion planner on different challenging examples, and
validated the generated motions on a real platform. We have discussed
the limits and potential extensions of our method, and we plan to
address them in future work.

\bigskip

This motion planning algorithm helps us achieve global planning in
complex environments, but it still cannot provide us with the ``best''
possible trajectories with respect to a given cost function. In the
next chapter, we focus on planning dynamic optimal motions for
humanoid robots in complex environments, such that the generated
trajectories solve both motion planning and optimal control
problems. We will therefore use the same constrained motion planning
algorithms which we presented in this chapter and combine them with
optimal control techniques.
